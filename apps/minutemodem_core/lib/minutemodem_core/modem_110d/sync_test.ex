defmodule MinuteModemCore.Modem110D.SyncTest do
  @moduledoc """
  Tests for Sync module.

  Verifies that preambles generated by TX can be detected by Sync.

  Run with: MinuteModemCore.Modem110D.SyncTest.run()
  """

  alias MinuteModemCore.Modem110D.{Sync, Preamble, Tables}

  def run do
    IO.puts("\n" <> String.duplicate("=", 60))
    IO.puts("Sync Tests")
    IO.puts(String.duplicate("=", 60) <> "\n")

    test_iq_to_8psk_conversion()
    test_correlation_perfect()
    test_sync_detection_clean()
    test_sync_detection_with_offset()
    test_tlc_detection()
    test_sync_vs_tlc_discrimination()

    IO.puts("\n" <> String.duplicate("=", 60))
    IO.puts("All Sync tests passed!")
    IO.puts(String.duplicate("=", 60) <> "\n")
  end

  def test_iq_to_8psk_conversion do
    IO.puts("1. Testing I/Q to 8-PSK conversion...")

    # Generate I/Q for each 8-PSK symbol
    for sym <- 0..7 do
      angle = sym * :math.pi() / 4
      i = :math.cos(angle)
      q = :math.sin(angle)

      # Convert back
      recovered = iq_to_8psk({i, q})
      assert recovered == sym, "Symbol #{sym} roundtrips"
    end

    IO.puts("   ✓ I/Q to 8-PSK conversion tests passed\n")
  end

  def test_correlation_perfect do
    IO.puts("2. Testing correlation with perfect match...")

    bw_khz = 3
    sync = Sync.new(bw_khz)

    # Build a Fixed section (1 Walsh symbol, di-bit 3)
    walsh_len = Tables.walsh_length(bw_khz)
    fixed_symbols = Preamble.expand_and_scramble([3], walsh_len, :fixed)

    # Correlate - should be high
    corr = Sync.correlate_fixed(sync, fixed_symbols)

    IO.puts("     Fixed correlation: #{Float.round(corr, 3)}")
    assert corr > 0.9, "Perfect Fixed correlation > 0.9"

    IO.puts("   ✓ Perfect correlation test passed\n")
  end

  def test_sync_detection_clean do
    IO.puts("3. Testing sync detection with clean signal...")

    bw_khz = 3
    sync = Sync.new(bw_khz, threshold: 0.5)

    # Build preamble
    preamble = Preamble.build(bw_khz, 6, :short, 7, m: 1, tlc_blocks: 0)

    # Convert to soft I/Q (perfect, no noise)
    soft_iq = Enum.map(preamble, &symbol_to_iq/1)

    # Search for sync
    result = Sync.search(sync, soft_iq)

    case result do
      {:found, sync_result, _updated} ->
        IO.puts("     Found sync at offset #{sync_result.sample_offset}")
        IO.puts("     Correlation peak: #{Float.round(sync_result.correlation_peak, 3)}")
        IO.puts("     Is TLC: #{sync_result.is_tlc}")

        assert sync_result.is_tlc == false, "Not TLC (no TLC blocks)"
        assert sync_result.correlation_peak > 0.8, "Strong correlation"

      {:searching, _} ->
        raise "Should have found sync in clean preamble"
    end

    IO.puts("   ✓ Clean sync detection test passed\n")
  end

  def test_sync_detection_with_offset do
    IO.puts("4. Testing sync detection with leading noise...")

    bw_khz = 3
    sync = Sync.new(bw_khz, threshold: 0.5)

    # Build preamble
    preamble = Preamble.build(bw_khz, 6, :short, 7, m: 1, tlc_blocks: 0)

    # Add random symbols before preamble
    noise_len = 50
    noise = for _ <- 1..noise_len, do: Enum.random(0..7)

    signal = noise ++ preamble
    soft_iq = Enum.map(signal, &symbol_to_iq/1)

    # Search for sync
    result = Sync.search(sync, soft_iq)

    case result do
      {:found, sync_result, _updated} ->
        IO.puts("     Found sync at offset #{sync_result.sample_offset}")
        IO.puts("     Expected offset near #{noise_len}")

        # Should find sync near the noise boundary
        assert sync_result.sample_offset >= noise_len - 5, "Offset after noise"
        assert sync_result.sample_offset <= noise_len + 5, "Offset near preamble start"

      {:searching, _} ->
        raise "Should have found sync despite leading noise"
    end

    IO.puts("   ✓ Sync detection with offset test passed\n")
  end

  def test_tlc_detection do
    IO.puts("5. Testing TLC detection...")

    bw_khz = 3
    sync = Sync.new(bw_khz, threshold: 0.5)

    # Build preamble WITH TLC
    preamble = Preamble.build(bw_khz, 6, :short, 7, m: 2, tlc_blocks: 2)

    # The TLC section comes first
    soft_iq = Enum.map(preamble, &symbol_to_iq/1)

    result = Sync.search(sync, soft_iq)

    case result do
      {:found, sync_result, _updated} ->
        IO.puts("     Found at offset #{sync_result.sample_offset}")
        IO.puts("     Is TLC: #{sync_result.is_tlc}")
        IO.puts("     Correlation: #{Float.round(sync_result.correlation_peak, 3)}")

        # First detection should be TLC (it comes before sync section)
        assert sync_result.is_tlc == true, "Should detect TLC first"

      {:searching, _} ->
        raise "Should have found TLC"
    end

    IO.puts("   ✓ TLC detection test passed\n")
  end

  def test_sync_vs_tlc_discrimination do
    IO.puts("6. Testing TLC vs Sync discrimination...")

    bw_khz = 3
    walsh_len = Tables.walsh_length(bw_khz)

    # Create sync detector
    sync = Sync.new(bw_khz)

    # Build TLC section (conjugate of Fixed PN)
    tlc_symbols = Preamble.build_tlc(walsh_len, 1)

    # Build Sync Fixed section (normal Fixed PN)
    sync_symbols = Preamble.expand_and_scramble([3], walsh_len, :fixed)

    # Test TLC correlation
    tlc_as_sync = Sync.correlate_fixed(sync, tlc_symbols)
    tlc_as_tlc = Sync.correlate_tlc(sync, tlc_symbols)

    IO.puts("     TLC symbols: sync_corr=#{Float.round(tlc_as_sync, 3)}, tlc_corr=#{Float.round(tlc_as_tlc, 3)}")
    assert tlc_as_tlc > tlc_as_sync, "TLC correlates better with TLC pattern"

    # Test Sync correlation
    sync_as_sync = Sync.correlate_fixed(sync, sync_symbols)
    sync_as_tlc = Sync.correlate_tlc(sync, sync_symbols)

    IO.puts("     Sync symbols: sync_corr=#{Float.round(sync_as_sync, 3)}, tlc_corr=#{Float.round(sync_as_tlc, 3)}")
    assert sync_as_sync > sync_as_tlc, "Sync correlates better with Sync pattern"

    IO.puts("   ✓ TLC vs Sync discrimination test passed\n")
  end

  # ===========================================================================
  # Helpers
  # ===========================================================================

  # Convert 8-PSK symbol to I/Q
  defp symbol_to_iq(sym) do
    angle = sym * :math.pi() / 4
    {:math.cos(angle), :math.sin(angle)}
  end

  # Convert I/Q back to 8-PSK symbol
  defp iq_to_8psk({i, q}) do
    angle = :math.atan2(q, i)
    angle = if angle < 0, do: angle + 2 * :math.pi(), else: angle
    symbol = round(angle / (:math.pi() / 4))
    rem(symbol, 8)
  end

  # Simple assertion helper
  defp assert(true, _msg), do: :ok
  defp assert(false, msg), do: raise("Assertion failed: #{msg}")
end

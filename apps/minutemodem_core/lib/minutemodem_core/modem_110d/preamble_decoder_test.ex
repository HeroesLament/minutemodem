defmodule MinuteModemCore.Modem110D.PreambleDecoderTest do
  @moduledoc """
  Tests for PreambleDecoder.

  Verifies that preambles generated by Preamble.build/5 can be
  correctly decoded back to WID and Downcount.

  Run with: MinuteModemCore.Modem110D.PreambleDecoderTest.run()
  """

  alias MinuteModemCore.Modem110D.{
    Preamble,
    PreambleDecoder,
    Tables,
    WID,
    Downcount
  }

  def run do
    IO.puts("\n" <> String.duplicate("=", 60))
    IO.puts("PreambleDecoder Tests")
    IO.puts(String.duplicate("=", 60) <> "\n")

    test_walsh_expansion()
    test_descramble_roundtrip()
    test_walsh_demod()
    test_decode_superframe_roundtrip()
    test_multiple_waveforms()
    test_multiple_counts()

    IO.puts("\n" <> String.duplicate("=", 60))
    IO.puts("All PreambleDecoder tests passed!")
    IO.puts(String.duplicate("=", 60) <> "\n")
  end

  def test_walsh_expansion do
    IO.puts("1. Testing Walsh sequence expansion...")

    # Base sequences from Table D-XIV
    base0 = Tables.walsh_sequence(0)  # [0, 0, 0, 0]
    base1 = Tables.walsh_sequence(1)  # [0, 4, 0, 4]
    base2 = Tables.walsh_sequence(2)  # [0, 0, 4, 4]
    base3 = Tables.walsh_sequence(3)  # [0, 4, 4, 0]

    # Expand to 32 (3 kHz Walsh length)
    exp0 = PreambleDecoder.expand_walsh(base0, 32)
    exp1 = PreambleDecoder.expand_walsh(base1, 32)

    assert length(exp0) == 32, "Expanded length is 32"
    assert Enum.all?(exp0, &(&1 == 0)), "Di-bit 0 expands to all zeros"

    # Di-bit 1: [0,4,0,4] repeated 8 times = [0,4,0,4,0,4,0,4,...]
    assert Enum.take(exp1, 4) == [0, 4, 0, 4], "First 4 are [0,4,0,4]"
    assert Enum.slice(exp1, 4, 4) == [0, 4, 0, 4], "Next 4 are [0,4,0,4]"
    assert length(exp1) == 32, "Di-bit 1 expanded length is 32"

    IO.puts("   ✓ Walsh expansion tests passed\n")
  end

  def test_descramble_roundtrip do
    IO.puts("2. Testing descramble/scramble roundtrip...")

    # Original symbols
    original = [0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3]
    pn = Enum.take(Tables.fixed_pn(), 12)

    # Scramble (mod 8 addition)
    scrambled = Enum.zip(original, pn)
                |> Enum.map(fn {s, p} -> rem(s + p, 8) end)

    # Descramble should recover original
    recovered = PreambleDecoder.descramble(scrambled, pn)

    assert recovered == original, "Descramble recovers original"

    IO.puts("   ✓ Descramble roundtrip passed\n")
  end

  def test_walsh_demod do
    IO.puts("3. Testing Walsh demodulation...")

    walsh_len = 32

    # Generate each Walsh sequence and verify demod recovers the di-bit
    for dibit <- 0..3 do
      base = Tables.walsh_sequence(dibit)
      expanded = PreambleDecoder.expand_walsh(base, walsh_len)

      recovered = PreambleDecoder.walsh_demod(expanded, walsh_len)
      assert recovered == dibit, "Walsh demod recovers di-bit #{dibit}"
    end

    IO.puts("   ✓ Walsh demodulation tests passed\n")
  end

  def test_decode_superframe_roundtrip do
    IO.puts("4. Testing TX/RX superframe roundtrip...")

    bw_khz = 3
    waveform = 6
    interleaver = :short
    constraint = 7
    m = 1  # Single super-frame

    # Build preamble with no TLC blocks
    # With m=1, long_fixed defaults to false (1 Fixed symbol)
    preamble = Preamble.build(bw_khz, waveform, interleaver, constraint, m: m, tlc_blocks: 0)

    walsh_len = Tables.walsh_length(bw_khz)

    # Preamble structure: TLC (0 blocks) + Sync
    # With m=1 and long_fixed=false:
    # Superframe = Fixed(1) + Count(4) + WID(5) = 10 Walsh symbols
    expected_len = 10 * walsh_len

    IO.puts("     Preamble length: #{length(preamble)}, expected: #{expected_len}")

    # The entire preamble IS the sync section (no TLC)
    sync_symbols = preamble

    # Debug: show what TX encoded
    tx_wid_dibits = Tables.encode_wid(waveform, interleaver, constraint)
    tx_count_dibits = Tables.encode_downcount(m - 1)
    IO.puts("     TX WID di-bits: #{inspect(tx_wid_dibits)}")
    IO.puts("     TX Count di-bits: #{inspect(tx_count_dibits)}")

    # Decode superframe with long_fixed: false (1 Fixed symbol)
    result = PreambleDecoder.decode_superframe(sync_symbols, bw_khz, long_fixed: false)

    case result do
      {:ok, wid, downcount} ->
        IO.puts("     RX WID: waveform=#{wid.waveform}, interleaver=#{wid.interleaver}, K=#{wid.constraint_length}")
        IO.puts("     RX Downcount: #{downcount.count}")

        assert wid.waveform == waveform, "Waveform matches: expected #{waveform}, got #{wid.waveform}"
        assert wid.interleaver == interleaver, "Interleaver matches"
        assert wid.constraint_length == constraint, "Constraint matches"
        assert downcount.count == m - 1, "Downcount is M-1 = #{m - 1}"
        IO.puts("   ✓ Superframe roundtrip passed")
        IO.puts("     Decoded: #{inspect(wid)}, #{inspect(downcount)}\n")

      {:error, reason} ->
        raise "Decode failed: #{inspect(reason)}"
    end
  end

  def test_multiple_waveforms do
    IO.puts("5. Testing multiple waveform roundtrips...")

    bw_khz = 3
    m = 1

    test_cases = [
      {0, :ultra_short, 7},   # Walsh
      {1, :short, 7},         # BPSK
      {5, :medium, 7},        # QPSK
      {6, :short, 9},         # 8-PSK, K=9
      {9, :long, 9},          # 64-QAM
      {11, :short, 7},        # 256-QAM
    ]

    for {waveform, interleaver, constraint} <- test_cases do
      preamble = Preamble.build(bw_khz, waveform, interleaver, constraint, m: m, tlc_blocks: 0)

      # With m=1 and no TLC, preamble IS the sync section
      {:ok, wid, _dc} = PreambleDecoder.decode_superframe(preamble, bw_khz, long_fixed: false)

      assert wid.waveform == waveform, "WF#{waveform} roundtrip"
      assert wid.interleaver == interleaver, "Interleaver #{interleaver}"
      assert wid.constraint_length == constraint, "K=#{constraint}"
    end

    IO.puts("   ✓ All #{length(test_cases)} waveform roundtrips passed\n")
  end

  def test_multiple_counts do
    IO.puts("6. Testing multiple downcount values...")

    bw_khz = 3
    waveform = 6
    interleaver = :short
    constraint = 7

    walsh_len = Tables.walsh_length(bw_khz)

    # Test M values from 1 to 10
    for m <- 1..10 do
      # For m > 1, long_fixed defaults to true (9 Fixed symbols)
      # For m = 1, long_fixed defaults to false (1 Fixed symbol)
      long_fixed = m > 1
      fixed_count = if long_fixed, do: 9, else: 1
      superframe_len = (fixed_count + 4 + 5) * walsh_len

      preamble = Preamble.build(bw_khz, waveform, interleaver, constraint, m: m, tlc_blocks: 0)

      # Decode each superframe and verify countdown
      for sf_idx <- 0..(m - 1) do
        expected_count = m - 1 - sf_idx
        sf_start = sf_idx * superframe_len
        sf_symbols = Enum.slice(preamble, sf_start, superframe_len)

        {:ok, _wid, downcount} = PreambleDecoder.decode_superframe(sf_symbols, bw_khz, long_fixed: long_fixed)

        assert downcount.count == expected_count,
          "M=#{m}, SF#{sf_idx}: expected count #{expected_count}, got #{downcount.count}"
      end
    end

    IO.puts("   ✓ Downcount tests passed for M=1..10\n")
  end

  # Simple assertion helper
  defp assert(true, _msg), do: :ok
  defp assert(false, msg), do: raise("Assertion failed: #{msg}")
end
